<!DOCTYPE html>
<meta charset='UTF-8'>
<title>VAW Deflection Viz</title>

<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/4.0.0/normalize.min.css' rel='stylesheet' type='text/css'>
<link href='https://fonts.googleapis.com/css?family=Roboto|Roboto+Condensed' rel='stylesheet' type='text/css'>

<script src='https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.16/d3.min.js'></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/tabletop.js/1.4.3/tabletop.min.js'></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/showdown/1.3.0/showdown.min.js'></script>

<script src='lib/tabletop.js'></script>

<link href='styles.css' rel='stylesheet' type='text/css'>

<div id='vaw'>
<!-- <div id='header'><img src='images/tackling_violence_roundel.jpg'/></div> -->

<svg id='viz'></svg>
</div>

<style>
.timeline path {
  stroke: black;
  fill: none;
  opacity: .4;
}
.timeline circle {
  r: 10px;
  opacity: .6;
}

.timeline line {
  stroke: black;
  fill: black;
  opacity: .4;
}

.timeline .entry .label .title {
  font-weight: 900;
}

.timeline .entry .label {
  visibility: hidden;
  pointer-events: none;
}

.timeline .entry rect {
  fill: white;
  opacity: 0.8;
  stroke: none;
}

.timeline .entry circle:hover ~ .label {
  visibility: visible;
}

.axis path {
  display: none;
}
.axis line {
  stroke: black;
  fill: none;
}
</style>

<script>

  /*
   * TODO.  Tuesday
   * - generate more data, across all categories
   * - start timeline before first data point
   * - mouseover to show timeline blurbs
   * - epaul email
   */

  var public_spreadsheet_url = 'https://docs.google.com/spreadsheets/d/12m1zaJVgUwJj3-F19XFAWnyWzbaRHdC3SB-ARDRpf4k/pubhtml';

  var width = 1150
  var height = 450

  var margins = { top: 30, right: 30, bottom: 35, left: 50 }

  var running = 25

  // load data
  Tabletop.init( { key: public_spreadsheet_url,
                   callback: visualize,
                   simpleSheet: true })

  // generate timeline
  function visualize(data) {
    type(data)

    var svg = d3.select('#viz')
      .attr('width', width + margins.left + margins.right)
      .attr('height', height + margins.top + margins.bottom)
      .append('g')
        .attr('transform', 'translate(' + [margins.left, margins.top] + ')')

    var categories = d3.set(data.map(function(d) { return d.category }))
    categories = categories.values()
    categories.sort()

    var color = d3.scale.ordinal()
      .domain(categories)
      .range(['#705685', '#ba0d5e', '#9da42a', '#e88b00', '#44739b', '#12a19a'])

    var y = d3.scale.ordinal()
      .domain(categories)
      .rangeRoundPoints([height / 3, height - 20])
    var image_size = y.range()[1] - y.range()[0]

    var years = d3.extent(data, function(d) { return d.year })

    var deflection = {}
    deflection[years[0] - running] = 0
    deflection[years[1] + running] = 0
    data.forEach(function(d0) {
      data.forEach(function(d1) {
        if(Math.abs(d1.year - d0.year) < running) {
          deflection[d1.year] = (deflection[d1.year] || 0) + 1
        }
      })
    })

    var x = d3.scale.linear()
      .domain(d3.extent(d3.keys(deflection)))
      .range([0, width])

    var deflect_scale = d3.scale.linear()
      .domain([0,d3.max(d3.values(deflection))])
      .range([0,height / 3])

    var y_axis = svg.append('g')
        .attr('class', 'y axis')
      .selectAll('image')
        .data(categories)
      .enter().append('image')
        .attr('width', image_size)
        .attr('height', image_size)
        .attr('x', -image_size)
        .attr('y', function(d) { return y(d) - image_size / 3 })
        .attr('xlink:href', function(d) { return 'images/' + d + '.jpg' })

    var x_axis = d3.svg.axis()
      .orient('bottom')
      .scale(x)
      .tickFormat(function(d) { return '' + d })

    svg.append('g')
      .attr('class', 'x axis')
      .attr('transform', 'translate(' + [0, height] + ')')
      .call(x_axis)

    var timeline = svg.append('g')
      .attr('class', 'timeline')

    var path = timeline.selectAll('path')
        .data(categories)
      .enter().append('path')

    path.attr('d', function(cat) {
      var line = d3.svg.line()
        .x(function(d) { return x(+d.key) })
        .y(function(d) { return y(cat) - deflect_scale(deflection[d.key]) })
        .interpolate('monotone')

      return line(d3.entries(deflection))
    })

    var entries_e = timeline.selectAll('.entry')
        .data(data)
      .enter().append('g')
        .attr('class', 'entry')
        .attr('transform', function(d) { return 'translate(' + x(d.year) + ')' })

    entries_e.append('circle')
        .attr('cy', function(d) { return y(d.category) - deflect_scale(deflection[d.year]) })
        .attr('fill', function(d) { return color(d.category) })

    var label = entries_e.append('g')
      .attr('class', 'label')

    label.append('line')
      .attr('y2', function(d) { return y(d.category) - deflect_scale(deflection[d.year]) })

    label.append('rect')
      .attr('x', 5)
      .attr('y', '-0.3em')
      .attr('width', 350)

    label.append('text')
      .attr('class', 'title')
      .attr('transform', 'translate(5)')
      .attr('x', 0)
      .attr('y', 0)
      .attr('dy', '.66em')
      .text(function(d) { return d.title })
      .call(wrap, 350)

    label.append('text')
      .attr('class', 'blurb')
      .attr('transform', 'translate(5)')
      .attr('x', 0)
      .attr('y', 0)
      .attr('dy', 3.66 +'em')
      .text(function(d) { return d.text })
      .call(wrap, 350)

    label.each(function() {
      var me = d3.select(this)
      var lines = me.selectAll('tspan').size() + 3
      me.select('rect')
        .attr('height', lines + 'em')
    })
  }

  // convert ajax data file to javascript types
  function type(data) {
    data.forEach(function(d) {
      d.year = +d.year
    })
  }

  // from https://bl.ocks.org/mbostock/7555321
  function wrap(text, width) {
    text.each(function() {
      var text = d3.select(this),
          words = text.text().split(/\s+/).reverse(),
          word,
          line = [],
          lineNumber = 0,
          lineHeight = 1.1, // ems
          y = text.attr("y"),
          dy = parseFloat(text.attr("dy")),
          tspan = text.text(null).append("tspan").attr("x", 0).attr("y", y).attr("dy", dy + "em");
      while (word = words.pop()) {
        line.push(word);
        tspan.text(line.join(" "));
        if (tspan.node().getComputedTextLength() > width) {
          line.pop();
          tspan.text(line.join(" "));
          line = [word];
          tspan = text.append("tspan").attr("x", 0).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
        }
      }
    });
}
</script>